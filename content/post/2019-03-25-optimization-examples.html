---
title: 'Optimization Examples in R'
author: 'Roger J. Bos, CFA'
date: '2019-01-16'
slug: Optimization-Examples-in-R
description: 'Optimization examples in R'
output: 
  html_document:
    number_sections: TRUE
    
---



<div id="prerequisites" class="section level1">
<h1>Prerequisites</h1>
<p>Before we get to the optimization examples, we will download the price history for a small number of ETFs and show how to calculate the returns, standard deviations, variance matrix and other inputs that we will need for the optimizer.</p>
<div id="prices" class="section level2">
<h2>Prices</h2>
<p>For these examples, we will download the daily prices for a handful of ETFs from Yahoo Finance, starting in 2003. Once the daily data is downloaded, we use the <em>to.weekly()</em> function to convert the prices to a weekly series (there is also a <em>to.monthly()</em> function) and then combine the series column by column into a data.frame.</p>
<pre class="r"><code>library(xts)
library(quantmod)</code></pre>
<pre><code>## Loading required package: TTR</code></pre>
<pre><code>## Registered S3 method overwritten by &#39;quantmod&#39;:
##   method            from
##   as.zoo.data.frame zoo</code></pre>
<pre><code>## Version 0.4-0 included new data defaults. See ?getSymbols.</code></pre>
<pre class="r"><code>library(ggplot2)</code></pre>
<pre><code>## 
## Attaching package: &#39;ggplot2&#39;</code></pre>
<pre><code>## The following object is masked _by_ &#39;.GlobalEnv&#39;:
## 
##     %+%</code></pre>
<pre class="r"><code>symbols &lt;- c(&quot;IWD&quot;,&quot;IWF&quot;,&quot;IWN&quot;,&quot;IWO&quot;,&quot;IWP&quot;,&quot;IWS&quot;)
initDate &lt;- &quot;2003-01-01&quot;
go &lt;- try(getSymbols(symbols, from = initDate))</code></pre>
<pre><code>## pausing 1 second between requests for more than 5 symbols</code></pre>
<pre><code>## pausing 1 second between requests for more than 5 symbols</code></pre>
<pre class="r"><code>prices &lt;- list()
for(i in 1:length(symbols)) {
  tmp &lt;- Ad(get(symbols[i]))
  tmp &lt;- to.weekly(tmp, indexat=&quot;%m/%d/%Y&quot;)
  tmp &lt;- tmp$tmp.Close
  names(tmp) &lt;- symbols[i]
  prices[[i]] &lt;- tmp
}
prices &lt;- do.call(cbind, prices)
tail(prices)</code></pre>
<pre><code>##                 IWD      IWF      IWN      IWO      IWP      IWS
## 2019-09-13 129.4231 161.3685 122.8302 201.2653 143.0413 90.31899
## 2019-09-20 128.6978 160.8699 120.7500 199.4289 143.0113 89.83158
## 2019-09-27 127.9700 158.4700 119.6300 192.0200 140.3100 89.40000
## 2019-10-04 126.4800 159.4100 117.4100 190.6300 140.9500 88.11000
## 2019-10-11 127.0900 160.5700 118.3700 191.8400 141.9400 88.48000
## 2019-10-15 127.8200 162.3400 119.0100 193.7900 143.0600 88.87000</code></pre>
</div>
<div id="returns" class="section level2">
<h2>Returns</h2>
<p>Once we have the prices, we can use the <em>lag.xts</em> function to calculate the (weekly) returns. Note the explicit call to <em>lag.xts</em> instead of just <em>lag</em>. A number of different packages have a <em>lag</em> function and they do not all work the same, so it is better to be safe here and explicitly call the one we want to use. We also create a log prices series just for good measure.</p>
<pre class="r"><code>prices &lt;- as.xts(prices)
returns &lt;- (prices / lag.xts(prices, k = 1) - 1)
returns[is.na(returns)] &lt;- 0
logprices &lt;- log(prices)
tail(logprices)</code></pre>
<pre><code>##                 IWD      IWF      IWN      IWO      IWP      IWS
## 2019-09-13 4.863087 5.083691 4.810803 5.304624 4.963133 4.503348
## 2019-09-20 4.857467 5.080596 4.793722 5.295458 4.962924 4.497937
## 2019-09-27 4.851796 5.065565 4.784404 5.257600 4.943854 4.493121
## 2019-10-04 4.840084 5.071480 4.765672 5.250334 4.948405 4.478586
## 2019-10-11 4.844895 5.078730 4.773815 5.256662 4.955404 4.482777
## 2019-10-15 4.850623 5.089693 4.779208 5.266775 4.963264 4.487175</code></pre>
<pre class="r"><code>tail(returns)</code></pre>
<pre><code>##                     IWD          IWF          IWN          IWO
## 2019-09-13  0.024139044 -0.004491409  0.064154538  0.035056224
## 2019-09-20 -0.005604539 -0.003090274 -0.016935458 -0.009124252
## 2019-09-27 -0.005654861 -0.014918095 -0.009275198 -0.037150462
## 2019-10-04 -0.011643338  0.005931741 -0.018557160 -0.007238824
## 2019-10-11  0.004822841  0.007276852  0.008176467  0.006347327
## 2019-10-15  0.005743993  0.011023161  0.005406767  0.010164705
##                     IWP          IWS
## 2019-09-13 -0.013974967  0.027614361
## 2019-09-20 -0.000209506 -0.005396561
## 2019-09-27 -0.018888779 -0.004804313
## 2019-10-04  0.004561321 -0.014429541
## 2019-10-11  0.007023803  0.004199319
## 2019-10-15  0.007890630  0.004407776</code></pre>
</div>
<div id="expected-returns-and-standard-deviation" class="section level2">
<h2>Expected returns and Standard Deviation</h2>
<p>The Greek letter <span class="math inline">\(\mu\)</span> (mu) is usually used to represent the expected return. Often we don’t have an actual forecast of the return, so we use the naive forecast, which is the historical mean return. The mean return can be easily calculated in R using the apply function on the second dimension (the columns) using the <em>mean</em> function. If one or more observations are NA then the mean function will return NA unless you tell it to remove NAs by setting na.rm = TRUE. Likewise, you can use apply with the standard deviation (sd) function, which is usually represented with the Greek letter <span class="math inline">\(\sigma\)</span>.</p>
<p>The standard deviation of returns is by far the most widely used measure of risk, but there are other options. One option is the downside deviation. Recall the formula for standard deviation is <span class="math inline">\(\sqrt\sum(x-\overline{x})^{2}\)</span>. The downside deviation calculation focuses only on the cases where <span class="math inline">\(x \lt \overline{x}\)</span>. The rational given for this is that it is the negative deviations in returns that are problematic. No on complains about large positive deviations, unless of course, you are short the stock, in which case you could use the upside deviation calculation. For the vast majority of stocks all the deviation calculations are very similar and as stated before, it is probably best to stick to the the regular standard deviation calculation.</p>
<pre class="r"><code>mu &lt;- apply(returns, MARGIN=2, FUN=mean, na.rm=TRUE)
sigma &lt;- apply(returns, MARGIN=2, FUN=sd)
sigma2 &lt;- sqrt(apply(returns, MARGIN=2, FUN=var))
library(magrittr)</code></pre>
<pre><code>## 
## Attaching package: &#39;magrittr&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:testthat&#39;:
## 
##     equals, is_less_than, not</code></pre>
<pre class="r"><code>sigma3 &lt;- apply(returns, MARGIN=2, FUN=var) %&gt;% sqrt()
rbind(sigma, sigma2, sigma3)</code></pre>
<pre><code>##               IWD        IWF        IWN        IWO        IWP        IWS
## sigma  0.02402808 0.02269799 0.02921164 0.03038832 0.02625404 0.02540209
## sigma2 0.02402808 0.02269799 0.02921164 0.03038832 0.02625404 0.02540209
## sigma3 0.02402808 0.02269799 0.02921164 0.03038832 0.02625404 0.02540209</code></pre>
<p>We show three different ways to calculate the same standard deviation above. The third one is essentially the same as the second, we just use the magrittr package in R which gives us the <em>%&gt;%</em> operator that makes the code easier to read. We will show you a fourth way to calculate standard deviation in the next section.</p>
<p>```</p>
</div>
<div id="variance-matrix" class="section level2">
<h2>Variance Matrix</h2>
<p>There are a couple of different ways to calculate the variance matrix (V). The simplest method is the esimate the sample covariance matrix.</p>
<pre class="r"><code>V &lt;- cov(returns, use=&quot;complete&quot;)
V</code></pre>
<pre><code>##              IWD          IWF          IWN          IWO          IWP
## IWD 0.0005773485 0.0005040316 0.0006352614 0.0006371931 0.0005767948
## IWF 0.0005040316 0.0005151987 0.0005798984 0.0006315692 0.0005735595
## IWN 0.0006352614 0.0005798984 0.0008533201 0.0008424399 0.0006998718
## IWO 0.0006371931 0.0006315692 0.0008424399 0.0009234498 0.0007574937
## IWP 0.0005767948 0.0005735595 0.0006998718 0.0007574937 0.0006892744
## IWS 0.0005918556 0.0005322335 0.0006991594 0.0007005762 0.0006325194
##              IWS
## IWD 0.0005918556
## IWF 0.0005322335
## IWN 0.0006991594
## IWO 0.0007005762
## IWP 0.0006325194
## IWS 0.0006452661</code></pre>
<pre class="r"><code>sigma4 &lt;- sqrt(diag(V))
sigma4</code></pre>
<pre><code>##        IWD        IWF        IWN        IWO        IWP        IWS 
## 0.02402808 0.02269799 0.02921164 0.03038832 0.02625404 0.02540209</code></pre>
<p>The <em>cov</em> function calculations the co-variance of the returns between each pair of stocks using the formula <span class="math inline">\(\sqrt\sum((x-\overline{x})(y-\overline{y})}\)</span>. On the diagonal of the matrix <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> are the same and the resulting calculation is the variance, so that is why <span class="math inline">\(\sqrt(diag(V))\)</span> produces the standard deviation, which you can verify matches the prior methods of calculating standard deviation.</p>
</div>
<div id="robust-methods-of-handling-outliers" class="section level2">
<h2>Robust methods of handling outliers</h2>
<p>To simulate an outlier, we will create a second returns series with only one observation different, but the difference being very large (an outlier).</p>
<pre class="r"><code>returns2 &lt;- returns
returns2[60,2]</code></pre>
<pre><code>##                      IWF
## 2004-02-20 -0.0002072267</code></pre>
<pre class="r"><code>returns2[60,2] &lt;- 5</code></pre>
<p>Graphically, we can see how changing just one observation changes the correlation relationship of that ETF with the other ETFs.</p>
<pre class="r"><code>par(mfrow=c(1,2))
plot(as.dendrogram( hclust(
    as.dist(sqrt(2-cor(returns, use=&quot;complete&quot;)))
  ), h = .1 ), horiz = TRUE, xlim = c(1.3, 1)
)
plot(as.dendrogram( hclust(
    as.dist(sqrt(2-cor(returns2, use=&quot;complete&quot;)))
  ), h = .1 ), horiz = TRUE, xlim = c(1.3, 1)
)</code></pre>
<p><img src="/post/2019-03-25-optimization-examples_files/figure-html/dendrogram-1.png" width="672" /></p>
<pre class="r"><code>V &lt;- cov(returns, use=&quot;pairwise&quot;)
V2 &lt;- cov(returns2, use=&quot;pairwise&quot;)
print(V[1:3, 1:3])</code></pre>
<pre><code>##              IWD          IWF          IWN
## IWD 0.0005773485 0.0005040316 0.0006352614
## IWF 0.0005040316 0.0005151987 0.0005798984
## IWN 0.0006352614 0.0005798984 0.0008533201</code></pre>
<pre class="r"><code>print(V2[1:3, 1:3])</code></pre>
<pre><code>##              IWD          IWF          IWN
## IWD 0.0005773485 0.0004781875 0.0006352614
## IWF 0.0004781875 0.0289967192 0.0005275467
## IWN 0.0006352614 0.0005275467 0.0008533201</code></pre>
<p>R package <em>corpcor</em> has a function called <em>cov.shrink</em> that shrinks all of the covariances closer to the mean, based on a <em>lambda.var</em> parameter. Using <em>lambda.var</em> of zero returns the (unshrunk) sample covariance matrix and we verify that below. If <em>lambda.var</em> is not specified it is automatically determined. You can see that the shrunk covariance matrix does a good job of minimizing the effect of the outlier.</p>
<pre class="r"><code>library(corpcor)
V2.sample &lt;- cov.shrink(returns2, lambda.var = 0)</code></pre>
<pre><code>## Specified shrinkage intensity lambda.var (variance vector): 0 
## 
## Estimating optimal shrinkage intensity lambda (correlation matrix): 0.0099</code></pre>
<pre class="r"><code>V2.shrink &lt;- cov.shrink(returns2)</code></pre>
<pre><code>## Estimating optimal shrinkage intensity lambda.var (variance vector): 1 
## 
## Estimating optimal shrinkage intensity lambda (correlation matrix): 0.0099</code></pre>
<pre class="r"><code>print(V2[1:3, 1:3])</code></pre>
<pre><code>##              IWD          IWF          IWN
## IWD 0.0005773485 0.0004781875 0.0006352614
## IWF 0.0004781875 0.0289967192 0.0005275467
## IWN 0.0006352614 0.0005275467 0.0008533201</code></pre>
<pre class="r"><code>print(V2.sample[1:3, 1:3])</code></pre>
<pre><code>##              IWD          IWF          IWN
## IWD 0.0005773485 0.0004734698 0.0006289941
## IWF 0.0004734698 0.0289967192 0.0005223421
## IWN 0.0006289941 0.0005223421 0.0008533201</code></pre>
<pre class="r"><code>print(V2.shrink[1:3, 1:3])</code></pre>
<pre><code>##               IWD           IWF           IWN
## IWD 0.00077129727 0.00008925256 0.00069118348
## IWF 0.00008925256 0.00077129727 0.00008099279
## IWN 0.00069118348 0.00008099279 0.00077129727</code></pre>
<pre class="r"><code>print(V[1:3, 1:3])</code></pre>
<pre><code>##              IWD          IWF          IWN
## IWD 0.0005773485 0.0005040316 0.0006352614
## IWF 0.0005040316 0.0005151987 0.0005798984
## IWN 0.0006352614 0.0005798984 0.0008533201</code></pre>
<pre class="r"><code># create exponential weights for a weighted covariance matrix
wgts &lt;- .98^(nrow(returns):1)
V.weighted &lt;- cov.shrink(returns, w=wgts)</code></pre>
<pre><code>## Estimating optimal shrinkage intensity lambda.var (variance vector): 0.6856 
## 
## Estimating optimal shrinkage intensity lambda (correlation matrix): 0.0375</code></pre>
<pre class="r"><code>returns2 &lt;- returns
returns2[60,2] &lt;- -100

V2 &lt;- cov(returns2, use=&quot;pairwise&quot;)
dim(V2)</code></pre>
<pre><code>## [1] 6 6</code></pre>
<pre class="r"><code>dim(V2.shrink)</code></pre>
<pre><code>## [1] 6 6</code></pre>
<pre class="r"><code>V2.shrink &lt;- cov.shrink(returns2, lambda = 0.99)</code></pre>
<pre><code>## Estimating optimal shrinkage intensity lambda.var (variance vector): 0.9978 
## 
## Specified shrinkage intensity lambda (correlation matrix): 0.99</code></pre>
<pre class="r"><code>V2</code></pre>
<pre><code>##              IWD           IWF          IWN          IWO          IWP
## IWD 0.0005773485  0.0010208910 0.0006352614 0.0006371931 0.0005767948
## IWF 0.0010208910 11.4035187457 0.0016268870 0.0018512065 0.0008938277
## IWN 0.0006352614  0.0016268870 0.0008533201 0.0008424399 0.0006998718
## IWO 0.0006371931  0.0018512065 0.0008424399 0.0009234498 0.0007574937
## IWP 0.0005767948  0.0008938277 0.0006998718 0.0007574937 0.0006892744
## IWS 0.0005918556  0.0011997672 0.0006991594 0.0007005762 0.0006325194
##              IWS
## IWD 0.0005918556
## IWF 0.0011997672
## IWN 0.0006991594
## IWO 0.0007005762
## IWP 0.0006325194
## IWS 0.0006452661</code></pre>
<pre class="r"><code>V2[1:3, 1:3]</code></pre>
<pre><code>##              IWD          IWF          IWN
## IWD 0.0005773485  0.001020891 0.0006352614
## IWF 0.0010208910 11.403518746 0.0016268870
## IWN 0.0006352614  0.001626887 0.0008533201</code></pre>
<pre class="r"><code>V2.shrink[1:3, 1:3]</code></pre>
<pre><code>##                IWD             IWF             IWN
## IWD 0.000770863390 0.0000005662970 0.0000069795705
## IWF 0.000000566297 0.0262802389424 0.0000007426072
## IWN 0.000006979570 0.0000007426072 0.0007714807623</code></pre>
<pre class="r"><code>library(ellipse)</code></pre>
<pre><code>## 
## Attaching package: &#39;ellipse&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:graphics&#39;:
## 
##     pairs</code></pre>
<pre class="r"><code>plotcorr(cov2cor(V))</code></pre>
<p><img src="/post/2019-03-25-optimization-examples_files/figure-html/unnamed-chunk-1-1.png" width="672" /></p>
</div>
<div id="risk-and-expected-returns" class="section level2">
<h2>Risk and Expected returns</h2>
<p><span class="math inline">\(\mu\)</span> is supposed to be the expected return. Often we don’t have any actual forcast of the return, so we use the naive forecast, which is the mean return. The mean return can be easily calculated in R using the apply function on the second dimension (the columns) using the <em>mean</em> function. If one or more observations are NA then the mean function will return NA unless you tell it to remove NAs by setting na.rm = TRUE.</p>
<pre class="r"><code>mu &lt;- apply(returns, MARGIN=2, FUN=mean, na.rm=TRUE)</code></pre>
<p>and <span class="math inline">\(\sigma\)</span> (sigma) is the standard deviation (the square root of the variance).</p>
<pre class="r"><code>sigma2 &lt;- apply(returns, 2, sd)
sigma &lt;- sqrt(diag(V))</code></pre>
<pre class="r"><code>plot_assets &lt;- function(V, mu) {
  rd &lt;- data.frame(mu=mu, sigma=sqrt(diag(V)))
  rd$assets &lt;- row.names(rd)
  
  ggplot(rd, aes(x = sigma, y = mu, color = assets)) +
    geom_point(size = 2) +
    ylab(&quot;Expected Return&quot;) +
    xlab(&quot;Standard Deviation (Risk)&quot;) +
    xlim(0, max(sigma)) + 
    ylim(0, 1.2*max(mu)) +
    ggtitle(&quot;Expected Returns versus Risk&quot;)
    
}
  
plot_assets(V, mu)</code></pre>
<p><img src="/post/2019-03-25-optimization-examples_files/figure-html/plot_assets-1.png" width="672" /></p>
</div>
</div>
<div id="optimization" class="section level1">
<h1>Optimization</h1>
<p>There are many optimization packages available for R. To start off, we will use the <em>solve.QP</em> package, then move on to show some other optimizers.</p>
<div id="equal-weighted" class="section level2">
<h2>Equal-weighted</h2>
<p>The portfolio optimization problem is the problem of finding the optimal weights of a portfolio. For example, how much you should invest in each asset to maximize some desirable quantity, say risk-adjusted return.</p>
<p>If you do not have any information about the assets (or, more realistically, any reliable information) you can assign the same weight to each asset: this maximizes the entropy (a measure of diversity) of the weights.</p>
<pre class="r"><code>plot_portfolio &lt;- function(w, label, V, mu) {

  require(quadprog)
  n &lt;- length(mu)
  A &lt;- cbind( # Each column is a constraint
    matrix( rep(1,n), nr=n ),
    diag(n)
  )
  b &lt;- c(1, rep(0,n))
  f &lt;- function(u) {
    solve.QP(Dmat = u * V, dvec = mu, Amat = A, bvec = b, meq = 1)$solution
  }
  require(parallel) # Run the computations in parallel
  risk_aversions &lt;- seq(.1, 100, length=ceiling(1e5/length(mu)))
  efw &lt;- mclapply(risk_aversions, f)
  efw &lt;- do.call(cbind, efw)
  x &lt;- sqrt( colSums(efw * (V %*% efw)) )
  y &lt;- t(efw) %*% mu
  
  # Efficient frontier points
  ef &lt;- data.frame(x=x, y=y)
  
  rd &lt;- data.frame(mu=mu, sigma=sqrt(diag(V)))
  rd$assets &lt;- row.names(rd)
  
  port_risk &lt;- sqrt( t(w) %*% V %*% w )
  port_return &lt;- t(w) %*% mu
  
  gg &lt;- ggplot(rd, aes(x = sigma, y = mu, color = assets)) +
    geom_point(size = 2) +
    ylab(&quot;Expected Return&quot;) +
    xlab(&quot;Standard Deviation (Risk)&quot;) +
    xlim(0, max(sigma)) + 
    ylim(0, 1.2*max(mu)) +
    ggtitle(&quot;Expected Returns versus Risk&quot;) +
    geom_segment(data = ef, aes(x = x, xend = dplyr::lead(x), y = y, yend = dplyr::lead(y)), color=&quot;grey&quot;) + 
    geom_point(aes(x = port_risk, y = port_return), color = &quot;cornflowerblue&quot;, size = 6) +
    geom_text(aes(x = port_risk, y = port_return, label = label, color=&quot;Portfolio&quot;), 
      position = position_dodge(width = 1), vjust = 1.5,) 
  print(gg)

}

plot_portfolio(w = rep(1/length(mu), length(mu)), label = &quot;Equal weighted&quot;, V = V, mu = mu)</code></pre>
<pre><code>## Loading required package: quadprog</code></pre>
<pre><code>## Loading required package: parallel</code></pre>
<pre><code>## Warning: Removed 1 rows containing missing values (geom_segment).</code></pre>
<p><img src="/post/2019-03-25-optimization-examples_files/figure-html/frontier-1.png" width="672" /></p>
</div>
<div id="mean-variance" class="section level2">
<h2>Mean-Variance</h2>
<p>The mean-variance portfolio maximizes the risk-adjusted expected return of the portfolio.
Usually this takes the form of <span class="math inline">\(\mu - \lambda * \sigma^{2}\)</span>, where
* <span class="math inline">\(\lambda\)</span> is the risk aversion parameter as determined by the investor
* <span class="math inline">\(\mu\)</span> is the expected return (probably proxied by the historical return)
* <span class="math inline">\(\sigma^{2}\)</span> is the risk measure, but other choices are available</p>
<p>We will use the <em>solve.QP</em> function in library quadprog, which requires converting the problem to the following format:</p>
<p>Functin call: solve.QP(Dmat, dvec, Amat, bvec, meq=0)
Find w
to maximize dvec’ w - 1/2 w’ Dmat w
such that Amat’ q &gt;= bvec (the first meq constraints are equalities)</p>
</div>
<div id="no-constraints" class="section level2">
<h2>No constraints</h2>
<pre class="r"><code>n &lt;- length(mu)
Amat &lt;- matrix(nr = n, nc = 0)
bvec &lt;- c()
r &lt;- solve.QP(Dmat = V, dvec = mu, Amat, bvec, meq = 0)
round(r$solution, 4)</code></pre>
<pre><code>## [1] -10.1548   8.4473  -3.3173  -1.0038  -1.9890  12.4618</code></pre>
<p>With absolutely no constraints the weights no not sum to one, rather summing to ’r sum(r$solution)`, the positions are highly levered, and there are many negative weights, implying shorting. We will now add a constraint to requie that the weights sum to one by using the Amat, bvec, and meq parameters as follows: <span class="math inline">\(Amat&#39; q &gt;= bvec\)</span>
We can create equality constraints, but they must be the first meq constraints and the remaining constraints will be inequality constraints. For long only we will only have one constraint, and that is that all the weights sum to exactly one.</p>
<pre class="r"><code>Amat &lt;- matrix(rep(1, n), nr = n)
bvec &lt;- 1
print(Amat)</code></pre>
<pre><code>##      [,1]
## [1,]    1
## [2,]    1
## [3,]    1
## [4,]    1
## [5,]    1
## [6,]    1</code></pre>
<pre class="r"><code>print(bvec)</code></pre>
<pre><code>## [1] 1</code></pre>
<p>As you can see, we created Amat as a column of all ones, bvec as a single 1, and set meq=1 so the function knows it is an equality constraint.</p>
<pre class="r"><code>r &lt;- solve.QP(Dmat=V, dvec=mu, Amat, bvec, meq=1)
sum(r$solution)</code></pre>
<pre><code>## [1] 1</code></pre>
<pre class="r"><code>round(r$solution, 2)</code></pre>
<pre><code>## [1] -10.27   2.07  -4.35   1.51   0.02  12.02</code></pre>
<p>Now the weights sum to one, but the leverage is still too high. Lets modify Amat and bvec as follows:</p>
<pre class="r"><code>Amat &lt;- cbind(matrix( rep(1,n), nr=n ), diag(n))
bvec &lt;- c(1, rep(0,n))
print(Amat)</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
## [1,]    1    1    0    0    0    0    0
## [2,]    1    0    1    0    0    0    0
## [3,]    1    0    0    1    0    0    0
## [4,]    1    0    0    0    1    0    0
## [5,]    1    0    0    0    0    1    0
## [6,]    1    0    0    0    0    0    1</code></pre>
<pre class="r"><code>print(bvec)</code></pre>
<pre><code>## [1] 1 0 0 0 0 0 0</code></pre>
<p>This make this concept concrete, here is how the matrix would look in equation form:</p>
<pre class="r"><code>eq &lt;- c(&quot;=&quot;, rep(&quot;&gt;=&quot;, n))
print(rbind(Amat, eq, bvec))</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
##      &quot;1&quot;  &quot;1&quot;  &quot;0&quot;  &quot;0&quot;  &quot;0&quot;  &quot;0&quot;  &quot;0&quot; 
##      &quot;1&quot;  &quot;0&quot;  &quot;1&quot;  &quot;0&quot;  &quot;0&quot;  &quot;0&quot;  &quot;0&quot; 
##      &quot;1&quot;  &quot;0&quot;  &quot;0&quot;  &quot;1&quot;  &quot;0&quot;  &quot;0&quot;  &quot;0&quot; 
##      &quot;1&quot;  &quot;0&quot;  &quot;0&quot;  &quot;0&quot;  &quot;1&quot;  &quot;0&quot;  &quot;0&quot; 
##      &quot;1&quot;  &quot;0&quot;  &quot;0&quot;  &quot;0&quot;  &quot;0&quot;  &quot;1&quot;  &quot;0&quot; 
##      &quot;1&quot;  &quot;0&quot;  &quot;0&quot;  &quot;0&quot;  &quot;0&quot;  &quot;0&quot;  &quot;1&quot; 
## eq   &quot;=&quot;  &quot;&gt;=&quot; &quot;&gt;=&quot; &quot;&gt;=&quot; &quot;&gt;=&quot; &quot;&gt;=&quot; &quot;&gt;=&quot;
## bvec &quot;1&quot;  &quot;0&quot;  &quot;0&quot;  &quot;0&quot;  &quot;0&quot;  &quot;0&quot;  &quot;0&quot;</code></pre>
<p>We can move along the efficient frontier (the grey line) by adjusting the risk-aversion parameter <span class="math inline">\(\lambda\)</span>. <span class="math inline">\(\lambda\)</span>=1 gives a balance between expected return and risk, whereas <span class="math inline">\(\lambda\)</span> &lt; 1 will shift the optimal portfolio to the right and <span class="math inline">\(\lambda\)</span> &gt; 1 will shift the optimal portfolio to the left.</p>
</div>
<div id="lambda-1-risk-averse-investor" class="section level2">
<h2><span class="math inline">\(\lambda\)</span> = 1: Risk-averse investor</h2>
<pre class="r"><code>r &lt;- solve.QP(Dmat=V, dvec=mu, Amat, bvec, meq=1)
sum(r$solution)</code></pre>
<pre><code>## [1] 1</code></pre>
<pre class="r"><code>round(r$solution, 2)</code></pre>
<pre><code>## [1] 0 0 0 0 1 0</code></pre>
<pre class="r"><code>plot_portfolio(w=r$solution, label=&quot;lambda = 1&quot;, V, mu)</code></pre>
<pre><code>## Warning: Removed 1 rows containing missing values (geom_segment).</code></pre>
<p><img src="/post/2019-03-25-optimization-examples_files/figure-html/longonly-1.png" width="672" /></p>
<p><span class="math inline">\(\lambda\)</span> &lt; 1 downplays the risk component and gives more importance to expected return, thus shifting the optimal portfolio to the right along the efficient frontier.</p>
</div>
<div id="lambda-1-more-risk-tolerant-investor" class="section level2">
<h2><span class="math inline">\(\lambda\)</span> &lt; 1: More risk-tolerant investor</h2>
<pre class="r"><code>r5 &lt;- solve.QP(Dmat = .5 * V, dvec = mu, Amat, bvec, meq = 1)
r1 &lt;- solve.QP(Dmat = .1 * V, dvec = mu, Amat, bvec, meq = 1)
plot_portfolio(w=r5$solution, label=&quot;lambda = .5&quot;, V, mu)</code></pre>
<pre><code>## Warning: Removed 1 rows containing missing values (geom_segment).</code></pre>
<pre class="r"><code>plot_portfolio(w=r1$solution, label=&quot;lambda = .1&quot;, V, mu)</code></pre>
<pre><code>## Warning: Removed 1 rows containing missing values (geom_segment).</code></pre>
<p><img src="/post/2019-03-25-optimization-examples_files/figure-html/riskTolerant-1.png" width="50%" /><img src="/post/2019-03-25-optimization-examples_files/figure-html/riskTolerant-2.png" width="50%" /></p>
<p><span class="math inline">\(\lambda\)</span> &gt; 1 increases the importance of the risk component and while keeping the expected returns the same, thus shifting the optimal portfolio to the left along the efficient frontier.</p>
</div>
</div>
<div id="lambda-1-more-risk-averse-investor" class="section level1">
<h1><span class="math inline">\(\lambda\)</span> &gt; 1: More risk-averse investor</h1>
<pre class="r"><code>r3 &lt;- solve.QP(Dmat = 3 * V, dvec = mu, Amat, bvec, meq = 1)
r10 &lt;- solve.QP(Dmat = 10 * V, dvec = mu, Amat, bvec, meq = 1)
plot_portfolio(w=r3$solution, label = &quot;lambda = 3&quot;, V, mu)</code></pre>
<pre><code>## Warning: Removed 1 rows containing missing values (geom_segment).</code></pre>
<pre class="r"><code>plot_portfolio(w=r10$solution, label = &quot;lambda = 10&quot;, V, mu)</code></pre>
<pre><code>## Warning: Removed 1 rows containing missing values (geom_segment).</code></pre>
<p><img src="/post/2019-03-25-optimization-examples_files/figure-html/riskAverse1-1.png" width="50%" /><img src="/post/2019-03-25-optimization-examples_files/figure-html/riskAverse1-2.png" width="50%" /></p>
</div>
<div id="minimum-volatilty-minv-vol" class="section level1">
<h1>Minimum Volatilty (Minv-Vol)</h1>
<p>The minimum volatility portfolio is achieved by setting <span class="math inline">\(\mu\)</span> to zero and solving the same optimization problem, so the optimizer finds the portfolio with the lowest risk regardless of the expected return. The minimum volatility portfolio is on the left and the mean variance portfolio is on the right for comparison purposes.</p>
<pre class="r"><code>r0 &lt;- solve.QP(Dmat = V, dvec = 0 * mu, Amat, bvec, meq = 1)
r &lt;- solve.QP(Dmat = V, dvec = mu, Amat, bvec, meq = 1)
plot_portfolio(w=r0$solution, label = &quot;Minv-Vol&quot;, V, mu)</code></pre>
<pre><code>## Warning: Removed 1 rows containing missing values (geom_segment).</code></pre>
<pre class="r"><code>plot_portfolio(w=r$solution, label = &quot;Mean-Variance vol&quot;, V, mu)</code></pre>
<pre><code>## Warning: Removed 1 rows containing missing values (geom_segment).</code></pre>
<p><img src="/post/2019-03-25-optimization-examples_files/figure-html/riskAverse-1.png" width="50%" /><img src="/post/2019-03-25-optimization-examples_files/figure-html/riskAverse-2.png" width="50%" /></p>
<p>We hope this helps you understand the basics of efficient frontiers and portfolio optimization, and gives you a starting point to optimizing portfolios in R.</p>
</div>
